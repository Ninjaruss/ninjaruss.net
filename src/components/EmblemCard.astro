---
interface Props {
  emblemSrc?: string;
  isInitiallyFlipped?: boolean;
}

const { emblemSrc, isInitiallyFlipped = false } = Astro.props;
const defaultEmblem = '/images/emblems/default.svg';
const cardBack = '/images/ygo-card-backing.png';
---

<div
  class:list={['emblem-card', { 'is-flipped': isInitiallyFlipped }]}
  data-emblem-card
  data-emblem-src={emblemSrc || defaultEmblem}
>
  <div class="emblem-card__flipper">
    <div class="emblem-card__face emblem-card__back">
      <img src={cardBack} alt="" class="emblem-card__img" />
    </div>
    <div class="emblem-card__face emblem-card__front">
      <img
        src={emblemSrc || defaultEmblem}
        alt="Page emblem"
        class="emblem-card__img"
        data-emblem-front
      />
    </div>
  </div>
</div>

<style>
  .emblem-card {
    perspective: 1000px;
    width: 100%;
    max-width: 240px;
    aspect-ratio: 63 / 88; /* Standard card ratio */
    cursor: pointer;
  }

  .emblem-card__flipper {
    position: relative;
    width: 100%;
    height: 100%;
    transform-style: preserve-3d;
    transition: transform 600ms cubic-bezier(0.4, 0, 0.2, 1);
    will-change: transform;
  }

  .emblem-card.is-flipped .emblem-card__flipper {
    transform: rotateY(180deg);
  }

  .emblem-card__face {
    position: absolute;
    inset: 0;
    backface-visibility: hidden;
    border-radius: var(--radius-md);
    overflow: hidden;
    border: var(--border-medium) solid var(--color-border-strong);
    background: var(--color-bg-elevated);
    box-shadow: var(--shadow-hard-sm);
    transition: box-shadow var(--transition-base), border-color var(--transition-base);
  }

  .emblem-card:hover .emblem-card__face {
    border-color: var(--color-gold-dim);
    box-shadow:
      var(--shadow-hard),
      0 0 25px rgba(255, 229, 44, 0.2);
  }

  .emblem-card__back {
    transform: rotateY(0deg);
  }

  .emblem-card__front {
    transform: rotateY(180deg);
  }

  .emblem-card__img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  /* Floating animation container */
  .emblem-card {
    transform: translateY(var(--float-y, 0));
    transition: transform 600ms cubic-bezier(0.4, 0, 0.2, 1);
  }

  /* Override transition during active floating */
  .emblem-card[style*="--float-y"] {
    transition: none;
  }

  /* Hover tilt effect */
  .emblem-card:hover .emblem-card__flipper {
    transform: rotateY(180deg) scale(1.02);
  }

  .emblem-card:not(.is-flipped):hover .emblem-card__flipper {
    transform: rotateY(0deg) scale(1.02);
  }

  /* Glow effect when flipped */
  .emblem-card.is-flipped .emblem-card__front {
    box-shadow: var(--shadow-glow), var(--shadow-hard);
  }

  /* Reduced motion: instant flip */
  @media (prefers-reduced-motion: reduce) {
    .emblem-card__flipper {
      transition: none;
      transform: rotateY(0deg) !important;
    }
  }
</style>

<script>
  function initEmblemTilt() {
    const emblemCards = document.querySelectorAll('.emblem-card');

    emblemCards.forEach((card) => {
      const flipper = card.querySelector('.emblem-card__flipper');
      if (!flipper) return;

      let isHovering = false;
      let rafId: number | null = null;

      function handleMouseMove(e: MouseEvent) {
        if (!isHovering) return;

        const rect = card.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        const mouseX = e.clientX - centerX;
        const mouseY = e.clientY - centerY;

        // Max 15 degree tilt
        const rotateY = (mouseX / (rect.width / 2)) * 15;
        const rotateX = -(mouseY / (rect.height / 2)) * 15;

        if (rafId) cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(() => {
          const baseRotation = card.classList.contains('is-flipped') ? 180 : 0;
          (flipper as HTMLElement).style.transform = `
            rotateY(${baseRotation + rotateY}deg)
            rotateX(${rotateX}deg)
            scale3d(1.03, 1.03, 1.03)
          `;
        });
      }

      function handleMouseEnter() {
        isHovering = true;
        (flipper as HTMLElement).style.transition = 'transform 150ms ease-out';
      }

      function handleMouseLeave() {
        isHovering = false;
        if (rafId) cancelAnimationFrame(rafId);

        const baseRotation = card.classList.contains('is-flipped') ? 180 : 0;
        (flipper as HTMLElement).style.transform = `rotateY(${baseRotation}deg) scale3d(1, 1, 1)`;
        (flipper as HTMLElement).style.transition = 'transform 600ms cubic-bezier(0.4, 0, 0.2, 1)';
      }

      // Only on hover-capable devices
      if (window.matchMedia('(hover: hover)').matches) {
        card.addEventListener('mouseenter', handleMouseEnter);
        card.addEventListener('mousemove', handleMouseMove as EventListener);
        card.addEventListener('mouseleave', handleMouseLeave);
      }
    });
  }

  function initEmblemFloat() {
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

    const emblemCards = document.querySelectorAll('.emblem-card');

    emblemCards.forEach((card) => {
      let floatRafId: number | null = null;
      let isFloating = false;
      let startTime: number | null = null;

      const FLOAT_AMPLITUDE = 10; // pixels (increased for visibility)
      const FLOAT_PERIOD = 35000; // 35 seconds

      function animate(currentTime: number) {
        if (!isFloating) {
          if (floatRafId) {
            // Transition out smoothly
            const currentY = parseFloat((card as HTMLElement).style.getPropertyValue('--float-y') || '0');
            if (Math.abs(currentY) > 0.1) {
              const targetY = currentY * 0.9;
              (card as HTMLElement).style.setProperty('--float-y', `${targetY}px`);
              floatRafId = requestAnimationFrame(animate);
            } else {
              (card as HTMLElement).style.removeProperty('--float-y');
              floatRafId = null;
            }
          }
          return;
        }

        if (startTime === null) startTime = currentTime;

        const elapsed = currentTime - startTime;
        const progress = (elapsed % FLOAT_PERIOD) / FLOAT_PERIOD;

        // Sine wave with ease
        const sineValue = Math.sin(progress * Math.PI * 2);
        const eased = -(Math.cos(Math.PI * ((sineValue + 1) / 2)) - 1) / 2;
        const translateY = (eased * 2 - 1) * FLOAT_AMPLITUDE;

        (card as HTMLElement).style.setProperty('--float-y', `${translateY}px`);
        floatRafId = requestAnimationFrame(animate);
      }

      card.addEventListener('emblemcard:idle-start', () => {
        if (isFloating) return;
        isFloating = true;
        startTime = null;
        floatRafId = requestAnimationFrame(animate);
      });

      card.addEventListener('emblemcard:idle-end', () => {
        isFloating = false;
        // animate() will handle transition out
      });
    });
  }

  function initEmblemLightbox() {
    const cards = document.querySelectorAll('.emblem-card');
    cards.forEach((card) => {
      const img = card.querySelector('.emblem-card__front img') as HTMLImageElement;
      if (img) {
        card.addEventListener('click', (e) => {
          e.preventDefault();
          const src = img.getAttribute('src');
          if (src && (window as any).openMediaLightbox) {
            (window as any).openMediaLightbox(src, 'Page emblem', 'image');
          }
        });
      }
    });
  }

  function init() {
    initEmblemTilt();
    initEmblemFloat();
    initEmblemLightbox();
  }

  document.addEventListener('astro:page-load', init);
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
</script>
