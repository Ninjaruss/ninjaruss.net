---
import { getCollection } from 'astro:content';
import SplitViewLayout from '../../layouts/SplitViewLayout.astro';
import ListItem from '../../components/ListItem.astro';
import TagList from '../../components/TagList.astro';
import RelatedContent from '../../components/RelatedContent.astro';
import fs from 'node:fs';
import path from 'node:path';

export async function getStaticPaths() {
  const entries = await getCollection('media');
  return entries.map((entry) => ({
    params: { slug: entry.slug },
    props: { entry },
  }));
}

const { entry } = Astro.props;
const { Content } = await entry.render();

// Get all media for the list
const allMedia = await getCollection('media', ({ data }) => !data.draft);
const sortedMedia = allMedia.sort((a, b) => a.data.title.localeCompare(b.data.title));

// Fetch all collections for related content
const allMediaEntries = allMedia;
const allNotes = await getCollection('notes', ({ data }) => !data.draft);
const allShowcase = await getCollection('showcase', ({ data }) => !data.draft);

const meta: Record<string, string> = {};
if (entry.data.content_type) {
  meta['Type'] = entry.data.content_type.charAt(0).toUpperCase() + entry.data.content_type.slice(1);
}

const formatDate = (date: Date) => {
  return date.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
    timeZone: 'UTC',
  });
};

// Strip markdown syntax for searchable content
function stripMarkdown(markdown: string): string {
  return markdown
    .replace(/```[\s\S]*?```/g, '')           // Remove code blocks
    .replace(/`[^`]+`/g, '')                  // Remove inline code
    .replace(/!\[.*?\]\(.*?\)/g, '')          // Remove images
    .replace(/\[([^\]]+)\]\([^\)]+\)/g, '$1') // Remove links, keep text
    .replace(/^#{1,6}\s+/gm, '')              // Remove headings
    .replace(/[*_]{1,2}([^*_]+)[*_]{1,2}/g, '$1') // Remove bold/italic
    .replace(/\s+/g, ' ')                     // Collapse whitespace
    .trim()
    .slice(0, 500);                           // Truncate to 500 chars
}

// Hybrid date approach: manual override or file mtime
const getUpdatedDate = () => {
  if (entry.data.updatedAt) return entry.data.updatedAt;

  try {
    const filePath = path.join(process.cwd(), 'src', 'content', 'media', `${entry.id}`);
    const stats = fs.statSync(filePath);
    return stats.mtime;
  } catch {
    return undefined;
  }
};

const updatedAt = getUpdatedDate();
---

<SplitViewLayout
  title="Media"
  description="Notes on anime, manga, films, and more."
  section="media"
  initialSlug={entry.slug}
  initialEmblem={entry.data.emblem}
>
  <Fragment slot="list">
    {sortedMedia.map((mediaEntry) => (
      <ListItem
        href={`/media/${mediaEntry.slug}`}
        slug={mediaEntry.slug}
        title={mediaEntry.data.title}
        tags={mediaEntry.data.tags}
        searchableContent={stripMarkdown(mediaEntry.body || '')}
        contentType={mediaEntry.data.content_type}
      />
    ))}
  </Fragment>

  <Fragment slot="detail">
    <article class="entry">
      {entry.data.emblem && <span data-page-emblem data-src={entry.data.emblem} hidden />}
      <div class="container">
        <header class="entry__header">
          <h1 class="entry__title">{entry.data.title}</h1>
          <div class="entry__meta">
            <div class="entry__meta-row">
              <TagList tags={entry.data.tags} size="md" />
            </div>
            <div class="entry__meta-dates">
              {entry.data.publishedAt && (
                <div class="meta-date-item">
                  <span class="meta-date-label">Published</span>
                  <span class="meta-date-value">{formatDate(entry.data.publishedAt)}</span>
                </div>
              )}
              {updatedAt && entry.data.publishedAt && updatedAt > entry.data.publishedAt && (
                <div class="meta-date-item">
                  <span class="meta-date-label">Last Edited</span>
                  <span class="meta-date-value">{formatDate(updatedAt)}</span>
                </div>
              )}
            </div>
          </div>
          {meta && Object.keys(meta).length > 0 && (
            <dl class="entry__details">
              {Object.entries(meta).map(([key, value]) => (
                <>
                  <dt>{key}</dt>
                  <dd>{value}</dd>
                </>
              ))}
            </dl>
          )}
        </header>

        <div class="entry__body">
          <div class="entry__content prose">
            <Content />
          </div>
        </div>

        {entry.data.collections.length > 0 && (
          <RelatedContent
            currentSlug={entry.slug}
            currentCollections={entry.data.collections}
            section="media"
            allReflections={allMediaEntries}
            allNotes={allNotes}
            allShowcase={allShowcase}
          />
        )}
      </div>
    </article>
  </Fragment>
</SplitViewLayout>
